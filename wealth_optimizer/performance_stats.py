from typing import List, Union, Tuple
import os
import numpy as np
import pandas as pd
from scipy import stats
from munch import Munch
from matplotlib import pyplot as plt

from wealth_optimizer.common_logger import logger


def plot_final_wealth_histogram(wealths: Union[np.array, List[float]], initial_wealth: float, target_wealth: float,
                                show: bool = False,
                                save_path: str = None,
                                label: str = None):
    plt.figure()
    plt.hist(wealths, bins='auto')
    if label is not None:
        title = 'Histogram of final sample wealth ({})'.format(label)
    else:
        title = 'Histogram of final sample wealth'
    plt.title(title)

    plt.axvline(x=initial_wealth, c='k')
    if target_wealth:
        plt.axvline(x=target_wealth, c='r')
    plt.plot()

    if save_path:
        if label is not None:
            filename = 'wealth_histogram_{}.png'.format(label)
        else:
            filename = 'wealth_histogram.png'
        plt.savefig(os.path.join(save_path, filename))

    if show:
        plt.show()


def compute_wealth_distribution_statistics(wealth_data: Union[np.array, List[float]], initial_wealth: float,
                                           target_wealth: float) -> Munch:
    """
    Compute statistics for the distribution of final wealth (over a number of asset price paths)
    - mean
    - variance / standard deviation
    - skewness and kurtosis
    - minimum and maximum
    - quantiles


    :param wealth_data: list or numpy array of wealths
    :param initial_wealth: initial wealth
    :param target_wealth: target wealth
    :return: dictionary of statistics
    """

    wealth_array = np.array(wealth_data)
    wealth_stats = stats.describe(wealth_array)

    mean_wealth = wealth_stats.mean
    median_wealth = np.median(wealth_array)
    min_wealth, max_wealth = wealth_stats.minmax
    max_wealth = wealth_array.max()

    if target_wealth:
        above_target = len(wealth_array[np.where(wealth_array > target_wealth)])
        fraction_above_target = above_target / len(wealth_array)

    else:
        above_target = None
        fraction_above_target = None
    above_initial = len(wealth_array[np.where(wealth_array > initial_wealth)])
    tail_risk = len(wealth_array[np.where(wealth_array <= 0.8 * initial_wealth)])

    fraction_above_initial = above_initial / len(wealth_array)
    tail_fraction = tail_risk / len(wealth_array)

    return Munch({
        'data': wealth_array,
        'mean': mean_wealth,
        'median': median_wealth,
        'variance': wealth_stats.variance,
        'stdev': np.sqrt(wealth_stats.variance),
        'min': min_wealth,
        'max': max_wealth,
        'skewness': wealth_stats.skewness,
        'kurtosis': wealth_stats.kurtosis,
        'above_target_wealth': fraction_above_target,
        'above_initial_wealth': fraction_above_initial,
        'tail_risk_20_pct': tail_fraction
    })


def log_statistics_info(statistics: Munch, label: str):
    """
    Log distribution statistics
    :param statistics:
    :param label:
    :return:
    """
    logger.info('---> {} -> avg: {:.4f}, median: {:.4f}, min: {:.4f}, max: {:.4f}'.format(
        label,
        statistics.mean,
        statistics.median,
        statistics.min,
        statistics.max))


def plot_wealth_trajectories(wealth_trajectories: List[np.array],
                             plot_every_nth: int = None,
                             show: bool = False,
                             save_path: str = None,
                             label: str = ''):
    """
    Plot the wealth trajectories generated by a control model over a set of paths
    :param label: provide a label in case the function is called several times (i.e for train and test)
    :param save_path:
    :param show:
    :param wealth_trajectories:
    :param plot_every_nth:
    :return:
    """

    plt.figure()
    for i, wealth_trajectory in enumerate(wealth_trajectories):

        if plot_every_nth:
            if i % plot_every_nth == 0:
                plt.plot(wealth_trajectory)
        else:
            plt.plot(wealth_trajectory)
    plt.xlabel('Time step')
    plt.ylabel('Wealth')
    plt.title('Wealth trajectories')

    if save_path:
        filename = 'wealth_trajectories_{}.png'.format(label)
        plt.savefig(os.path.join(save_path, filename))

    if show:
        plt.show()


def plot_trajectory_mean_and_quantiles(wealth_trajectories: List[np.array], quantiles: List[float] = None,
                                       show: bool = False,
                                       save_path: str = None,
                                       label: str = ''):
    combined_array = np.array(wealth_trajectories)

    means = np.mean(combined_array, axis=0)
    plt.figure()
    if quantiles:
        quantiles_output = {}

        for i, q in enumerate(quantiles):
            quantiles_output[i] = {'quantile': q, 'trajectory': np.quantile(combined_array, q, axis=0)}
            plt.plot(quantiles_output[i]['trajectory'], label='{:.3f} quantile'.format(q))

    plt.plot(means, label='Average')
    plt.xlabel('Time step')
    plt.ylabel('Wealth')
    plt.title('Wealth trajectories')
    plt.legend()

    if save_path:
        filename = 'wealth_trajectories_quantiles_{}.png'.format(label)
        plt.savefig(os.path.join(save_path, filename))
    if show:
        plt.show()


def plot_asset_allocations(allocations: List[List[np.array]], assets: List[str],
                           plot_every_nth: int = None,
                           y_limits: Tuple = None,
                           show: bool = False,
                           save_path: str = None,
                           label: str = ''):
    """
    Plot the control (asset allocation) along one or more paths.

    For every path, the allocations is a list of numpy arrays, representing the controls at each time step
    :param save_path:
    :param y_limits:
    :param plot_every_nth:
    :param show:
    :param allocations:
    :param assets:
    :return:
    """

    for plot_asset in assets:

        ix = assets.index(plot_asset)
        plt.figure()
        if y_limits:
            plt.ylim(y_limits)

        for i, path_allocations in enumerate(allocations):
            allocs = np.array(path_allocations)[:, ix]
            # if plot_every_nth:
            #     if i % plot_every_nth == 0:
            #         plt.plot(allocs[1:])
            # else:
            plt.plot(allocs)

        plt.title('Allocation of asset: {}'.format(assets[ix]))
        plt.xlabel('Time step')
        plt.ylabel('Fraction of Current Wealth')

        if save_path:
            filename = 'asset_allocations_{}_{}.png'.format(assets[ix], label)
            plt.savefig(os.path.join(save_path, filename))

    if show:
        plt.show()


def plot_asset_allocation_quantiles(allocations: List[List[np.array]], assets: List[str],
                                    quantiles: List[float] = None,
                                    y_limits: Tuple = None,
                                    show: bool = False,
                                    save_path: str = None,
                                    label: str = ''):
    """
    Plots asset allocation point-wise mean and quantiles over the investment horizon and saves/displays a chart
    :param label:
    :param save_path:
    :param y_limits:
    :param allocations:
    :param assets:
    :param quantiles:
    :param show:
    :return:
    """

    for plot_asset in assets:

        ix = assets.index(plot_asset)
        plt.figure()
        if y_limits:
            plt.ylim(y_limits)
        asset_means = None
        asset_quantiles = {}
        asset_path_allocations = []
        for i, path_allocations in enumerate(allocations):
            # rint(path_allocations)
            # on a given path
            allocs = np.array(path_allocations)[:, ix]
            asset_path_allocations.append(allocs)

        combined_array = np.array(asset_path_allocations)
        means = np.mean(combined_array, axis=0)
        if quantiles:
            quantiles_output = {}

            for i, q in enumerate(quantiles):
                quantiles_output[i] = {'quantile': q, 'trajectory': np.quantile(combined_array, q, axis=0)}
                plt.plot(quantiles_output[i]['trajectory'], label='{:.3f} quantile'.format(q))

        plt.plot(means, label='Average')
        plt.title('Allocation of asset: {}'.format(assets[ix]))
        plt.xlabel('Time step')
        plt.ylabel('Fraction of Current Wealth')
        plt.legend()

        if save_path:
            filename = 'asset_quantile_{}_{}.png'.format(assets[ix], label)
            plt.savefig(os.path.join(save_path, filename))

    if show:
        plt.show()
